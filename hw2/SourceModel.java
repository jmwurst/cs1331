import java.io.FileReader;
import java.io.IOException;

/**
* Given a set of training corpora and a string, construct first-order
* Markov chains of the transition probabilities between letters found
* sequentially in the corpora and, for each model, compute the probability
* that the string was generated by it.
*
* @author Justin Wurst
* @version 09-09-18
*/
public class SourceModel {

    private double[][] matrix;
    private String modelName, corpusFile;

    /**
    * Initializes a SourceModel object and generates a matrix that represents
    * a probabilistic model based on a given corpus file.
    *
    * @param  modelName    name of the model to generate
    * @param  corpusFile   name of the file containing the target corpus
    */
    public SourceModel(String modelName, String corpusFile) throws IOException {
        this.modelName = modelName;
        this.corpusFile = corpusFile;
        System.out.printf("Training %s model ... ", this.modelName);

        FileReader in = new FileReader(this.corpusFile);
        int[][] counts = new int[26][26];
        int prev = 0, cur = 0;
        while ((cur = in.read()) != -1) {
            if (Character.isAlphabetic(cur)) {
                cur = Character.toLowerCase(cur);
                if (Character.isAlphabetic(prev)) {
                    counts[prev - 'a'][cur - 'a']++;
                }
                prev = cur;
            }
        }
        in.close();

        matrix = new double[26][26];
        for (int p = 0; p < 26; p++) {
            double rowSum = 0.0;
            for (int c = 0; c < 26; c++) {
                rowSum += counts[p][c];
            }
            for (int c = 0; c < 26; c++) {
                matrix[p][c] = (rowSum == 0 || counts[p][c] == 0)
                               ? 0.01
                               : counts[p][c] / rowSum;
            }
        }

        System.out.println("done.");
    }

    /**
    * @return the name of the generated model
    */
    public String getName() {
        return modelName;
    }

    /**
    * @return the model's name and a tabular representation
    *         of the probabilistic matrix
    */
    public String toString() {
        String out = "Model: " + modelName + "\n ";
        for (int c = 97; c <= 122; c++) {
            out += String.format("    %s", (char) c + "");
        }
        out += "\n";
        for (int r = 0; r < 26; r++) {
            out += (char) (r + 97) + "";
            for (int c = 0; c < 26; c++) {
                out += String.format("%5.2f", matrix[r][c]);
            }
            out += "\n";
        }
        return out;
    }

    /**
    * Determines the probability that a given string was generated
    * by a source model.
    *
    * @param  test  the string to evaluate for probability
    *               of generation
    *
    * @return a double which represents the probability
    */
    public double probability(String test) {
        double prob = 1.0;
        int prev = 0, cur = 0;
        for (int i = 0; i < test.length(); i++) {
            cur = test.charAt(i);
            if (Character.isAlphabetic(cur)) {
                cur = Character.toLowerCase(cur);
                if (Character.isAlphabetic(prev)) {
                    prob *= matrix[prev - 'a'][cur - 'a'];
                }
                prev = cur;
            }
        }
        return prob;
    }

    /**
    * Creates SourceModel objects for each of a set of given corpora
    * and prints the probabilites that a given string was generated by
    * each model.
    *
    * @param  args  index 0 - (args.length - 2) are the file names of corpora
    *               index args.length - 1 is the string to evaluate
    */
    public static void main(String[] args) throws IOException {
        String testStr = args[args.length - 1];
        SourceModel[] models = new SourceModel[args.length - 1];
        int longestName = -1;
        for (int i = 0; i < models.length; i++) {
            models[i] = new SourceModel(args[i].substring(0, args[i].indexOf('.')),
                                        args[i]);
            longestName = Math.max(longestName, models[i].getName().length());
        }

        System.out.printf("Analyzing: %s%n", testStr);
        double[] allProbs = new double[models.length];
        int highestProbIndex = 0;
        double totalProb = 0.0, highestProbVal = -1;
        for (int i = 0; i < allProbs.length; i++) {
            allProbs[i] = models[i].probability(testStr);
            totalProb += allProbs[i];
            if (allProbs[i] > highestProbVal) {
                highestProbIndex = i;
                highestProbVal = allProbs[i];
            }
        }
        for (int i = 0; i < allProbs.length; i++) {
            allProbs[i] /= totalProb;
            System.out.printf("Probability that the test string is %" + longestName + "s: %4.2f%n",
                              models[i].getName(),
                              allProbs[i]);
        }
        System.out.printf("Test string is most likely %s.%n",
                          models[highestProbIndex].getName());
    }
}